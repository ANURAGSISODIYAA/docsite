<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dioxus Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Create book from markdown files. Like Gitbook but implemented in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Getting Setup</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="concepts/00-index.html"><strong aria-hidden="true">4.</strong> Describing the UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/vnodes.html"><strong aria-hidden="true">4.1.</strong> Intro to Elements</a></li><li class="chapter-item expanded "><a href="concepts/components.html"><strong aria-hidden="true">4.2.</strong> Intro to Components</a></li><li class="chapter-item expanded "><a href="concepts/exporting_components.html"><strong aria-hidden="true">4.3.</strong> Reusing, Importing, and Exporting Components</a></li><li class="chapter-item expanded "><a href="concepts/conditional_rendering.html"><strong aria-hidden="true">4.4.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="concepts/lists.html"><strong aria-hidden="true">4.5.</strong> Lists</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/interactivity.html"><strong aria-hidden="true">5.</strong> Adding Interactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/event_handlers.html"><strong aria-hidden="true">5.1.</strong> Event handlers</a></li><li class="chapter-item expanded "><a href="concepts/errorhandling.html"><strong aria-hidden="true">5.2.</strong> User Input and Controlled Components</a></li><li class="chapter-item expanded "><a href="concepts/lifecycles.html"><strong aria-hidden="true">5.3.</strong> Lifecycle, updates, and effects</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/managing_state.html"><strong aria-hidden="true">6.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/hooks.html"><strong aria-hidden="true">6.1.</strong> Hooks and Internal State</a></li><li class="chapter-item expanded "><a href="concepts/sharedstate.html"><strong aria-hidden="true">6.2.</strong> Global State</a></li><li class="chapter-item expanded "><a href="concepts/errorhandling.html"><strong aria-hidden="true">6.3.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="concepts/effects.html"><strong aria-hidden="true">6.4.</strong> Effects</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/async.html"><strong aria-hidden="true">7.</strong> Working with Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/asynctasks.html"><strong aria-hidden="true">7.1.</strong> Tasks</a></li><li class="chapter-item expanded "><a href="concepts/suspense.html"><strong aria-hidden="true">7.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="concepts/asynccallbacks.html"><strong aria-hidden="true">7.3.</strong> Async Callbacks</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">8.</strong> Putting it all together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/new_app.html"><strong aria-hidden="true">8.1.</strong> New app</a></li><li class="chapter-item expanded "><a href="tutorial/structure.html"><strong aria-hidden="true">8.2.</strong> Structuring our app</a></li><li class="chapter-item expanded "><a href="tutorial/state.html"><strong aria-hidden="true">8.3.</strong> Defining State</a></li><li class="chapter-item expanded "><a href="tutorial/components.html"><strong aria-hidden="true">8.4.</strong> Defining Components</a></li><li class="chapter-item expanded "><a href="tutorial/styling.html"><strong aria-hidden="true">8.5.</strong> Styling</a></li><li class="chapter-item expanded "><a href="tutorial/publishing.html"><strong aria-hidden="true">8.6.</strong> Publishing</a></li></ol></li><li class="chapter-item expanded "><a href="depth/topics.html"><strong aria-hidden="true">9.</strong> Topics in Depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="depth/rsx.html"><strong aria-hidden="true">9.1.</strong> RSX</a></li><li class="chapter-item expanded "><a href="depth/components.html"><strong aria-hidden="true">9.2.</strong> Components</a></li><li class="chapter-item expanded "><a href="depth/props.html"><strong aria-hidden="true">9.3.</strong> Props</a></li><li class="chapter-item expanded "><a href="depth/memoization.html"><strong aria-hidden="true">9.4.</strong> Memoization</a></li><li class="chapter-item expanded "><a href="depth/performance.html"><strong aria-hidden="true">9.5.</strong> Performance</a></li><li class="chapter-item expanded "><a href="depth/testing.html"><strong aria-hidden="true">9.6.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/advanced_guides.html"><strong aria-hidden="true">10.</strong> Advanced Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/memoization.html"><strong aria-hidden="true">10.1.</strong> Memoization</a></li><li class="chapter-item expanded "><a href="concepts/rsx_in_depth.html"><strong aria-hidden="true">10.2.</strong> RSX in Depth</a></li><li class="chapter-item expanded "><a href="concepts/rsx.html"><strong aria-hidden="true">10.3.</strong> Building Elements with NodeFactory</a></li><li class="chapter-item expanded "><a href="concepts/custom_elements.html"><strong aria-hidden="true">10.4.</strong> Custom Elements</a></li><li class="chapter-item expanded "><a href="concepts/custom_renderer.html"><strong aria-hidden="true">10.5.</strong> Custom Renderer</a></li><li class="chapter-item expanded "><a href="concepts/server_side_components.html"><strong aria-hidden="true">10.6.</strong> Server-side components</a></li><li class="chapter-item expanded "><a href="concepts/bundline.html"><strong aria-hidden="true">10.7.</strong> Bundling and Distributing</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Web</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> Getting Started</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Down-casting Nodes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Wrapping Web APIs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> SSR</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Wrapping Web APIs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Desktop</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Wrapping Web APIs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Mobile</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Wrapping Web APIs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Reference Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Anti-patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Children</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Conditional Rendering</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.4.</strong> Controlled Inputs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.5.</strong> Custom Elements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.6.</strong> Empty Components</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.7.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.8.</strong> Fragments</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.9.</strong> Global CSS</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.10.</strong> Inline Styles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.11.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.12.</strong> Listeners</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.13.</strong> Memoization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.14.</strong> Node Refs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.15.</strong> Spread Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.16.</strong> State Management</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.17.</strong> Suspense</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.18.</strong> task</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.19.</strong> Testing</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dioxus Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook/tree/master/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./images/dioxuslogo_full.png" alt="dioxuslogo" /></p>
<p><strong>Dioxus</strong> is a framework and ecosystem for building fast, scalable, and robust user interfaces with the Rust programming language. This guide will help you get up-and-running with Dioxus running on the Web, Desktop, Mobile, and more.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App((cx, props): Component&lt;()&gt;) -&gt; Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    ))
};
<span class="boring">}
</span></code></pre></pre>
<p>The Dioxus API and patterns closely resemble React - if this guide is lacking in any general concept or an error message is confusing, we recommend substituting &quot;React&quot; for &quot;Dioxus&quot; in your web search terms. A major goal of Dioxus is to provide a familiar toolkit for UI in Rust, so we've chosen to follow in the footsteps of popular UI frameworks (React, Redux, etc) - if you know React, then you already know Dioxus. If you don't know either, this guide will still help you!</p>
<h3 id="web-support"><a class="header" href="#web-support">Web Support</a></h3>
<hr />
<p>The Web is the most-supported target platform for Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the <code>dioxus</code> crate with the <code>web</code> feature enabled. Because of the Wasm limitation, not every crate will work with your web-apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).</p>
<p>Because the web is a fairly mature platform, we expect there to be very little API churn for web-based features.</p>
<p><a href="">Jump to the getting started guide for the web.</a></p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/dioxusLabs/todomvc/">TodoMVC</a></li>
<li><a href="">ECommerce</a></li>
<li><a href="">Photo Editor</a></li>
</ul>
<p><a href="https://github.com/dioxusLabs/todomvc/"><img src="https://github.com/DioxusLabs/todomvc/raw/master/example.png" alt="todomvc" /></a></p>
<h3 id="ssr-support"><a class="header" href="#ssr-support">SSR Support</a></h3>
<hr />
<p>Dioxus supports server-side rendering! In a pinch, you can literally &quot;debug&quot; the VirtualDom:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dom = VirtualDom::new(App);
println!(&quot;{:?}, dom&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>For rendering statically to an <code>.html</code> file or from a WebServer, then you'll want to make sure the <code>ssr</code> feature is enabled in the <code>dioxus</code> crate and use the <code>dioxus::ssr</code> API. We don't expect the SSR API to change drastically in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contents = dioxus::ssr::render_vdom(&amp;dom, |c| c);
<span class="boring">}
</span></code></pre></pre>
<p><a href="">Jump to the getting started guide for SSR.</a></p>
<p>Examples:</p>
<ul>
<li><a href="">Example DocSite</a></li>
<li><a href="">Tide WebServer</a></li>
<li><a href="">Markdown to fancy HTML generator</a></li>
</ul>
<h3 id="desktop-support"><a class="header" href="#desktop-support">Desktop Support</a></h3>
<hr />
<p>The desktop is a powerful target for Dioxus, but is currently limited in capability when compared to the Web platform. Currently, desktop apps are rendered with the platform's WebView library, but your Rust code is running natively on a native thread. This means that browser APIs are <em>not</em> available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs <em>are</em> accessible, so streaming, WebSockets, filesystem, etc are all viable APIs. In the future, we plan to move to a custom webrenderer-based DOM renderer with WGPU integrations.</p>
<p>Desktop APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.</p>
<p><a href="">Jump to the getting started guide for Desktop.</a></p>
<p>Examples:</p>
<ul>
<li><a href="">File explorer</a></li>
<li><a href="">Bluetooth scanner</a></li>
<li><a href="">Device Viewer</a></li>
</ul>
<p><a href="https://github.com/dioxusLabs/file-explorer/"><img src="https://github.com/DioxusLabs/file-explorer-example/raw/master/image.png" alt="FileExplorerExample" /></a></p>
<h3 id="mobile-support"><a class="header" href="#mobile-support">Mobile Support</a></h3>
<hr />
<p>Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with the platform's WebView, meaning that animations, transparency, and native widgets are not currently achievable. In addition, iOS is the only supported Mobile Platform. It is possible to get Dioxus running on Android and rendered with WebView, but the Rust windowing library that Dioxus uses - tao - does not currently supported Android.</p>
<p>Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.</p>
<p><a href="">Jump to the getting started guide for Mobile.</a></p>
<p>Examples:</p>
<ul>
<li><a href="">Todo App</a></li>
<li><a href="">Chat App</a></li>
</ul>
<h3 id="liveview--server-component-support"><a class="header" href="#liveview--server-component-support">LiveView / Server Component Support</a></h3>
<hr />
<p>The internal architecture of Dioxus was designed from day one to support the <code>LiveView</code> use-case, where a web server hosts a running app for each connected user. As of today, there is no first-class LiveView support - you'll need to wire this up yourself. </p>
<p>While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are &quot;live&quot; and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.</p>
<h3 id="multithreaded-support"><a class="header" href="#multithreaded-support">Multithreaded Support</a></h3>
<hr />
<p>The Dioxus VirtualDom, sadly, is not currently <code>Send</code>. Internally, we use quite a bit of interior mutability which is not thread-safe. This means you can't easily use Dioxus with most web frameworks like Tide, Rocket, Axum, etc. </p>
<p>To solve this, you'll want to spawn a VirtualDom on its own thread and communicate with it via channels.</p>
<p>When working with web frameworks that require <code>Send</code>, it is possible to render a VirtualDom immediately to a String - but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to create a pool of VirtualDoms.</p>
<p>Ultimately, you can always wrap the VirtualDom with a <code>Send</code> type and manually uphold the <code>Send</code> guarantees yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Dioxus aims to provide a fast, friendly, and portable toolkit for building user interfaces with Rust.</p>
<p>This Getting Setup guide assumes you'll be building a small desktop application. You can check out the <a href="../platforms/00-index.html">Platform Specific Guides</a> for more information on setting up Dioxus for any of the various supported platforms.</p>
<h1 id="setting-up-dioxus"><a class="header" href="#setting-up-dioxus">Setting up Dioxus</a></h1>
<p>Dioxus requires a few main things to get up and running:</p>
<ul>
<li>
<p>The <a href="https://www.rust-lang.org">Rust compiler</a> and associated build tooling</p>
</li>
<li>
<p>An editor of your choice, ideally configured with the <a href="https://rust-analyzer.github.io">Rust-Analyzer LSP plugin</a></p>
</li>
</ul>
<p>Dioxus integrates very well with the Rust-Analyzer IDE plugin which will provide appropriate syntax highlighting, code navigation, folding, and more.</p>
<h3 id="dioxus-cli-for-dev-server-bundling-etc"><a class="header" href="#dioxus-cli-for-dev-server-bundling-etc">Dioxus-CLI for dev server, bundling, etc.</a></h3>
<p>We also recommend installing the Dioxus CLI. The Dioxus CLI automates building and packaging for various targets and integrates with simulators, development servers, and app deployment. To install the CLI, you'll need cargo (should be automatically installed with Rust):</p>
<pre><code>$ cargo install dioxus-cli
</code></pre>
<p>You can update the dioxus-cli at any time with:</p>
<pre><code>$ cargo install --force dioxus-cli
</code></pre>
<p>If your version of the CLI is out of date, it'll remind you to update whenever a new version is uploaded to Rust's package manager <a href="https://crates.io">crates.io</a>. We use a dedicated 1st-party CLI to save you from having to run potentially untrusted code every time you add a crate to your project - as is standard in the NPM ecosystem. You can vet the source of the Dioxus-CLI yourself at its <a href="https://github.com/jkelleyrtp/dioxus/tree/master/packages/cli">GitHub repo</a>.</p>
<h3 id="suggested-extensions"><a class="header" href="#suggested-extensions">Suggested extensions</a></h3>
<p>If you want to keep your traditional <code>npm install XXX</code> workflow for adding packages, you might want to install <code>cargo-edit</code> and a few other fun <code>cargo</code> extensions:</p>
<ul>
<li><a href="https://github.com/killercup/cargo-edit">cargo edit</a> for adding dependencies from the CLI</li>
<li><a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> for expanding macro calls</li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html">cargo tree</a> - an integrated cargo command that lets you inspect your dependency tree</li>
</ul>
<p>That's it! We won't need to touch NPM/WebPack/Babel/Parcel, etc. However, you <em>can</em> configure your app to use WebPack with <a href="https://rustwasm.github.io/wasm-pack/book/tutorials/hybrid-applications-with-webpack/using-your-library.html">traditional WASM-pack tooling</a>.</p>
<h2 id="rust-knowledge"><a class="header" href="#rust-knowledge">Rust Knowledge</a></h2>
<p>With Rust, things like benchmarking, testing, and documentation are included in the language. We strongly recommend going through the official Rust book <em>completely</em>. However, our hope is that a Dioxus app can serve as a great first project. With Dioxus you'll learn about:</p>
<ul>
<li>Error handling</li>
<li>Structs, Functions, Enums</li>
<li>Closures</li>
<li>Macros</li>
</ul>
<p>We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge on async, lifetimes, or smart pointers until you really start building complex Dioxus apps.</p>
<p>We strongly encourage exploring the guides for more information on how to work with the integrated tooling:</p>
<ul>
<li><a href="Testing.html">Testing</a></li>
<li><a href="Documentation.html">Documentation</a></li>
<li><a href="Benchmarking.html">Benchmarking</a></li>
<li><a href="Building.html">Building</a></li>
<li><a href="Modules.html">Modules</a></li>
<li><a href="Crates.html">Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's put together a simple &quot;hello world&quot; to get acquainted with Dioxus. The Dioxus-CLI has an equivalent to &quot;create-react-app&quot; built-in, but setting up Dioxus apps is simple enough to not need additional tooling.</p>
<p>This demo will build a simple desktop app. Check out the platform-specific setup guides on how to port your app to different targets.</p>
<h3 id="a-new-project-with-cargo"><a class="header" href="#a-new-project-with-cargo">A new project with Cargo</a></h3>
<p>First, let's start a new project. Rust has the concept of executables and libraries. Executables have a <code>main.rs</code> and libraries have <code>lib.rs</code>. A project may have both. Our <code>hello world</code> will be an executable - we expect our app to launch when we run it! Cargo provides this for us:</p>
<pre><code class="language-shell">$ cargo new --bin hello-dioxus
</code></pre>
<p>Now, we can <code>cd</code> into our project and poke around:</p>
<pre><code class="language-shell">$ cd hello-dioxus
$ tree
.
├── Cargo.toml
├── .git
├── .gitignore
└── src
    └── main.rs
</code></pre>
<p>We are greeted with a pre-initialized git repository, our code folder (<code>src</code>) and our project file (<code>Cargo.toml</code>).</p>
<p>Our <code>src</code> folder holds our code. Our <code>main.rs</code> file holds our <code>fn main</code> which will be executed when our app is ran.</p>
<pre><code class="language-shell">$ more src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Right now, whenever our app is launched, &quot;Hello world&quot; will be echoed to the terminal.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello-dioxus v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello-dioxus`
Hello, world!
</code></pre>
<p>Our <code>Cargo.toml</code> file holds our dependencies and project flags.</p>
<pre><code class="language-shell">$ cat Cargo.toml
</code></pre>
<pre><code class="language-toml">[package]
name = &quot;hello-dioxus&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

</code></pre>
<h3 id="adding-dioxus-as-a-dependency"><a class="header" href="#adding-dioxus-as-a-dependency">Adding Dioxus as a dependency</a></h3>
<p>To use the Dioxus library, we'll want to add the most recent version of <code>Dioxus</code> to our crate. If you have <code>cargo edit</code> installed, simply call:</p>
<pre><code class="language-shell">$ cargo add dioxus --features desktop
</code></pre>
<p>It's very important to add <code>dioxus</code> with the <code>desktop</code> feature for this example. The <code>dioxus</code> crate is a batteries-include crate that combines a bunch of utility crates together, ensuring compatibility of the most important parts of the ecosystem. Under the hood, the <code>dioxus</code> crate configures various renderers, hooks, debug tooling, and more. The <code>desktop</code> feature ensures the we only depend on the smallest set of required crates to compile and render.</p>
<p>If you plan to develop extensions for the <code>Dioxus</code> ecosystem, please use the <code>dioxus</code> crate with the <code>core</code> feature to limit the amount of dependencies your project brings in.</p>
<h3 id="our-first-app"><a class="header" href="#our-first-app">Our first app</a></h3>
<p>Now, let's edit our <code>main.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use dioxus::prelude::*;


fn main() {
    dioxus::desktop::start(App, |c| c);
}

fn App((cx, props): Component&lt;()&gt;) -&gt; Element {
    cx.render(rsx! (
        div { &quot;Hello, world!&quot; }
    ))
}
</code></pre></pre>
<p>At this point, you could call <code>cargo run</code> and be greeted with a simple <code>Hello, World!</code> screen:</p>
<p><img src="images/helloworld.png" alt="hello world" /></p>
<h3 id="dissecting-our-example"><a class="header" href="#dissecting-our-example">Dissecting our example</a></h3>
<p>This bit of code imports everything from the the <code>prelude</code> module. This brings into scope the right traits, types, and macros needed for working with Dioxus.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dioxus::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>This initialization code launches a Tokio runtime on a helper thread where your code will run. Then, the WebView renderer will be launched on the main-thread. Due to platform requirements, the main thread is blocked by your app's event loop.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    dioxus::desktop::start(App, |c| c);
}
</code></pre></pre>
<p>Finally, our app. Every component in Dioxus is a function that takes in <code>Context</code> and <code>Props</code> and returns an <code>Element</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App((cx, props): Component&lt;()&gt;) -&gt; Element {
    cx.render(rsx! {
        div { &quot;Hello, world!&quot; }
    })    
}
<span class="boring">}
</span></code></pre></pre>
<p>In cases where props need to borrow from their parent, you will need to specify lifetimes using the function syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App&lt;'a&gt;(cx: Component&lt;'a, ()&gt;) -&gt; Element&lt;'a&gt; {
    cx.render(rsx! {
        div { &quot;Hello, world!&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Writing <code>fn App((cx, props): Component&lt;()&gt;) -&gt; Element {</code> might become tedious. Rust will also let you write functions as static closures, but these types of Components cannot have props that borrow data.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static App: Fc&lt;()&gt; = |cx, props| {
    cx.render(rsx! {
        div { &quot;Hello, world!&quot; }
    })
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-context-object"><a class="header" href="#the-context-object">The <code>Context</code> object</a></h3>
<p>In React, you'll want to store data between renders with hooks. However, hooks rely on global variables which make them difficult to integrate in multi-tenant systems like server-rendering. In Dioxus, you are given an explicit <code>Context</code> object to control how the component renders and stores data.</p>
<h3 id="the-rsx-macro"><a class="header" href="#the-rsx-macro">The <code>rsx!</code> macro</a></h3>
<p>Next, we're greeted with the <code>rsx!</code> macro. This lets us add a custom DSL for declaratively building the structure of our app. The semantics of this macro are similar to that of JSX and HTML, though with a familiar Rust-y interface. The <code>html!</code> macro is also available for writing components with a JSX/HTML syntax.</p>
<p>The <code>rsx!</code> macro is lazy: it does not immediately produce elements or allocates, but rather builds a closure which can be rendered with <code>cx.render</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-topics"><a class="header" href="#core-topics">Core Topics</a></h1>
<p>In this chapter of the book, we'll cover some core topics on how Dioxus works and how to best leverage the features to build a beautiful, reactive app.</p>
<p>At a very high level, Dioxus is simply a Rust framework for <em>declaring</em> user interfaces and <em>reacting</em> to changes.</p>
<ol>
<li>We declare what we want our user interface to look like given a state using Rust-based logic and control flow.</li>
<li>We declare how we want our state to change when the user triggers an event.</li>
</ol>
<h2 id="declarative-ui"><a class="header" href="#declarative-ui">Declarative UI</a></h2>
<p>Dioxus is a <em>declarative</em> framework. This means that instead of manually writing calls to &quot;create element&quot; and &quot;set element background to red,&quot; we simply <em>declare</em> what we want the element to look like and let Dioxus handle the differences.</p>
<p>Let's pretend that we have a stoplight we need to control - it has a color state with red, yellow, and green as options.</p>
<p>Using an imperative approach, we would have to manually declare each element and then handlers for advancing the stoplight.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = Container::new();

let green_light = Light::new().color(&quot;green&quot;).enabled(true);
let yellow_light = Light::new().color(&quot;yellow&quot;).enabled(false);
let red_light = Light::new().color(&quot;red&quot;).enabled(false);
container.push(green_light);
container.push(yellow_light);
container.push(red_light);

container.onclick(move |_| {
    if red_light.enabled() {
        red_light.set_enabled(false);
        green_light.set_enabled(true);
    } else if yellow_light.enabled() {
        yellow_light.set_enabled(false);
        red_light.set_enabled(true);
    } else if green_light.enabled() {
        green_light.set_enabled(false);
        yellow_light.set_enabled(true);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>As the UI grows in scale, our logic to keep each element in the proper state would grow exponentially. This can become very unwieldy and lead to out-of-sync UIs that harm user experience.</p>
<p>Instead, with Dioxus, we <em>declare</em> what we want our UI to look like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = &quot;red&quot;;

rsx!(
    Container {
        Light { color: &quot;red&quot;, enabled: {state == &quot;red&quot;}  }
        Light { color: &quot;yellow&quot;, enabled: {state == &quot;yellow&quot;}  }
        Light { color: &quot;green&quot;, enabled: {state == &quot;green&quot;}  }
        onclick: |_| {
            state = match state {
                &quot;green&quot; =&gt; &quot;yellow&quot;,
                &quot;yellow&quot; =&gt; &quot;red&quot;,
                &quot;red&quot; =&gt; &quot;green&quot;,
            }
        }
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Remember: this concept is not new! Many frameworks are declarative - with React being the most popular. Declarative frameworks tend to be much more enjoyable to work with than imperative frameworks.</p>
<p>Here's some reading about declaring UI in React:</p>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js">https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js</a></p>
</li>
<li>
<p><a href="https://medium.com/@myung.kim287/declarative-vs-imperative-251ce99c6c44">https://medium.com/@myung.kim287/declarative-vs-imperative-251ce99c6c44</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-your-first-ui-with-elements"><a class="header" href="#declaring-your-first-ui-with-elements">Declaring your first UI with Elements</a></h1>
<p>Every user interface you've ever used is just a symphony of tiny widgets working together to abstract over larger complex functions. In Dioxus, we call these tiny widgets &quot;Elements.&quot; Using Components, you can easily compose Elements into larger groups to form even larger structures: Apps.</p>
<p>Because Dioxus is mostly used with HTML/CSS renderers, the default Element &quot;collection&quot; is HTML. Provided the <code>html</code> feature is not disabled, we can declare Elements using the <code>rsx!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use dioxus::prelude::*;
</span>rsx!(
    div {}
)
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, we can render this call using Dioxus-SSR to produce valid HTML:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use dioxus::prelude::*;
</span>dioxus::ssr::render_lazy(rsx!(
    div {}
))
<span class="boring">}
</span></code></pre></pre>
<p>Produces:</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>We can construct any valid HTML tag with the <code>tag {}</code> pattern and expect the resulting HTML structure to resemble our declaration.</p>
<h2 id="composing-elements"><a class="header" href="#composing-elements">Composing Elements</a></h2>
<p>Of course, we need more complex structures to make our apps actually useful! Just like HTML, the <code>rsx!</code> macro lets us nest Elements inside of each other.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use dioxus::prelude::*;
</span>rsx!(
    div {
        h1 {}
        h2 {}
        p {}
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, the generated HTML for this structure would look like:</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>With the default configuration, any Element defined within the <code>dioxus-html</code> crate can be declared in this way. To create your own new elements, see the <code>Custom Elements</code> Advanced Guide.</p>
<h2 id="text-elements"><a class="header" href="#text-elements">Text Elements</a></h2>
<p>Dioxus also supports a special type of Element: Text. Text Elements do not accept children, but rather just string literals denoted with double quotes.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx! (
    &quot;hello world&quot;
)
<span class="boring">}
</span></code></pre></pre>
<p>Text Elements can be composed within other Elements:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx! (
    div {
        h1 { &quot;hello world&quot; }
        p { &quot;Some body content&quot; }
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Text can also be formatted with any value that implements <code>Display</code>. We use <a href="https://docs.rs/fstrings/0.2.3/fstrings/">f-string formatting</a> - a &quot;coming soon&quot; feature for stable Rust that is familiar for Python and JavaScript users:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;Bob&quot;;
rsx! ( &quot;hello {name}&quot; )
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, you cannot drop in arbitrary expressions directly into the string literal. In the cases where we need to compute a complex value, we'll want to use <code>format_args!</code> directly. Due to specifics of how the <code>rsx!</code> macro (we'll cover later), our call to <code>format_args</code> must be contained within curly braces <em>and</em> square braces.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!( {[format_args!(&quot;Hello {}&quot;, if enabled { &quot;Jack&quot; } else { &quot;Bob&quot; } )]} )
<span class="boring">}
</span></code></pre></pre>
<p>This is different from React's way of generating arbitrary markup but fits within idiomatic Rust. </p>
<p>Typically, with Dioxus, you'll just want to compute your substrings outside of the <code>rsx!</code> call:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = if enabled { &quot;Jack&quot; } else { &quot;Bob&quot; };
rsx! ( &quot;hello {name}&quot; )
<span class="boring">}
</span></code></pre></pre>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Every Element in your User Interface will have some sort of properties that the renderer will use when drawing to the screen. These might inform the renderer if the component should be hidden, what its background color should be, or to give it a specific name or ID.</p>
<p>To do this, we use the familiar struct-style syntax that Rust provides. Commas are optional:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        hidden: true,
        background_color: &quot;blue&quot;,
        class: &quot;card color-{mycolor}&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Each field is defined as a method on the element in the <code>dioxus-html</code> crate. This prevents you from misspelling a field name and lets us provide inline documentation. When you need to use a field not defined as a method, you have two options:</p>
<ol>
<li>file an issue if the attribute <em>should</em> be enabled</li>
<li>add a custom attribute on-the-fly</li>
</ol>
<p>To use custom attributes, simply put the attribute name in quotes followed by a colon:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        &quot;customAttr&quot;: &quot;important data here&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Note: the name of the custom attribute must match exactly what you want the renderer to output. All attributes defined as methods in <code>dioxus-html</code> follow the snake_case naming convention. However, they internally translate their snake_case convention to HTML's camelCase convention.</p>
<h2 id="listeners"><a class="header" href="#listeners">Listeners</a></h2>
<p>Listeners are a special type of Attribute that only accept functions. Listeners let us attach functionality to our Elements by running a provided closure whenever the specified Listener is triggered.</p>
<p>We'll cover listeners in more depth in the Listeners chapter, but for now, just know that every listener must start with the <code>on</code> keyword and can accept either a closure or an expression wrapped in curly braces.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        onclick: move |_| {}
        onmouseover: {handler},
    }
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on"><a class="header" href="#moving-on">Moving On</a></h2>
<p>This chapter just scratches the surface on how Elements can be defined.</p>
<p>We learned:</p>
<ul>
<li>Elements are the basic building blocks of User Interfaces</li>
<li>Elements can contain other elements </li>
<li>Elements can either be a named container or text</li>
<li>Some Elements have properties that the renderer can use to draw the UI to the screen</li>
</ul>
<p>Next, we'll compose Elements together to form components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-components"><a class="header" href="#introduction-to-components">Introduction to Components</a></h1>
<p>In the previous chapter, we learned about Elements and how they can be composed to create a basic User Interface. In this chapter, we'll learn how to group Elements together to form Components.</p>
<h2 id="what-is-a-component"><a class="header" href="#what-is-a-component">What is a component?</a></h2>
<p>In short, a component is a special function that takes an input and outputs a group of Elements. Typically, Components serve a single purpose: group functionality of a User Interface. Much like a function encapsulates some specific computation task, a Component encapsulates some specific rendering task.</p>
<h3 id="learning-through-prior-art"><a class="header" href="#learning-through-prior-art">Learning through prior art</a></h3>
<p>Let's take a look at a post on r/rust and see if we can sketch out a component representation.</p>
<p><img src="concepts/../images/reddit_post.png" alt="Reddit Post" /></p>
<p>This component has a bunch of important information:</p>
<ul>
<li>The score</li>
<li>The number of comments</li>
<li>How long ago it was posted</li>
<li>The url short address</li>
<li>The title</li>
<li>The username of the original poster</li>
</ul>
<p>If we wanted to sketch out these requirements in Rust, we would start with a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Post {
    score: i32,
    comment_count: u32,
    post_time: Instant,
    url: String,
    title: String,
    original_poster_name: String
}
<span class="boring">}
</span></code></pre></pre>
<p>If we look at the layout of the component, we notice quite a few buttons and functionality:</p>
<ul>
<li>Upvote/Downvote</li>
<li>View comments</li>
<li>Share</li>
<li>Save</li>
<li>Hide</li>
<li>Give award</li>
<li>Report</li>
<li>Crosspost</li>
<li>Filter by site</li>
<li>View article</li>
<li>Visit user </li>
</ul>
<p>If we included all this functionality in one <code>rsx!</code> call, it would be huge! Instead, let's break the post down into some core pieces:</p>
<p><img src="concepts/../images/reddit_post_components.png" alt="Post as Component" /></p>
<ul>
<li><strong>VoteButtons</strong>: Upvote/Downvote</li>
<li><strong>TitleCard</strong>: Title, Filter-By-Url</li>
<li><strong>MetaCard</strong>: Original Poster, Time Submitted</li>
<li><strong>ActionCard</strong>: View comments, Share, Save, Hide, Give award, Report, Crosspost</li>
</ul>
<h3 id="modeling-with-dioxus"><a class="header" href="#modeling-with-dioxus">Modeling with Dioxus</a></h3>
<p>When designing these components, we can start by sketching out the hierarchy using Dioxus. In general, our &quot;Post&quot; component will simply be comprised of our four sub-components. We would start the process by defining our &quot;Post&quot; component. Our component will take in all of the important data we listed above as part of its input.</p>
<p>Unlike normal functions, Dioxus components must explicitly define a single struct to contain all the inputs. These are commonly called &quot;Properties&quot; (props). Our component will be a combination of these properties and a function to render them.</p>
<p>Our props must implement the <code>Properties</code> trait and - if the component does not borrow any data - <code>PartialEq</code>. Both of these can be done automatically through derive macros:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Properties, PartialEq)]
struct PostProps {
    id: Uuid,
    score: i32,
    comment_count: u32,
    post_time: Instant,
    url: String,
    title: String,
    original_poster: String
}
<span class="boring">}
</span></code></pre></pre>
<p>And our render function:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Post((cx, props): Component&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;post-container&quot;
            VoteButtons {
                score: props.score,
            }
            TitleCard {
                title: props.title,
                url: props.url,
            }
            MetaCard {
                original_poster: props.original_poster,
                post_time: props.post_time,
            }
            ActionCard {
                post_id: props.id
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>When we render components, we use the traditional Rust struct syntax to declare their properties. Dioxus will automatically call &quot;into&quot; on the property fields, cloning when necessary. Notice how our <code>Post</code> component is simply a collection of important smaller components wrapped together in a single container.</p>
<p>Let's take a look at the <code>VoteButtons</code> component. For now, we won't include any interactivity - just the rendering the vote buttons and score to the screen.</p>
<p>Most of your Components will look exactly like this: a Props struct and a render function. As covered before, we'll build our User Interface with the <code>rsx!</code> macro and HTML tags. However, with components, we must actually &quot;render&quot; our HTML markup. Calling <code>cx.render</code> converts our &quot;lazy&quot; <code>rsx!</code> structure into an <code>Element</code>. Every component must take a tuple of <code>Context</code> and <code>&amp;Props</code> and return an <code>Element</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[derive(PartialEq, Props)]
struct VoteButtonsProps {
    score: i32
}

fn VoteButtons((cx, props): Component&lt;VoteButtonsProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;votebuttons&quot;
            div { class: &quot;arrow up&quot; }
            div { class: &quot;score&quot;, &quot;{props.score}&quot;}
            div { class: &quot;arrow down&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>You can avoid clones using borrowed component syntax. For example, let's say we passed the TitleCard title as an <code>&amp;str</code> instead of <code>String</code>. In JavaScript, the string would simply be copied by reference - none of the contents would be copied, but rather the reference to the string's contents are copied. In Rust, this would be similar to calling <code>clone</code> on <code>Rc&lt;str&gt;</code>.</p>
<p>Because we're working in Rust, we can choose to either use <code>Rc&lt;str&gt;</code>, clone <code>Title</code> on every re-render of <code>Post</code>, or simply borrow it. In most cases, you'll just want to let <code>Title</code> be cloned. </p>
<p>To enable borrowed values for your component, we need to add a lifetime to let the Rust compiler know that the output <code>Element</code> borrows from the component's props.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Properties)]
struct TitleCardProps&lt;'a&gt; {
    title: &amp;'a str,
}

fn TitleCard&lt;'a&gt;((cx, props): Component&lt;'a, TitleCardProps&gt;) -&gt; Element&lt;'a&gt; {
    cx.render(rsx!{
        h1 { &quot;{props.title}&quot; }
    })
}   
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-context-object-1"><a class="header" href="#the-context-object-1">The <code>Context</code> object</a></h2>
<p>Though very similar with React, Dioxus is different in a few ways. Most notably, React components will not have a <code>Context</code> parameter in the component declaration. </p>
<p>Have you ever wondered how the <code>useState()</code> call works in React without a <code>this</code> object to actually store the state? </p>
<p>React uses global variables to store this information which must be carefully managed, especially in environments with multiple React roots - like the server.</p>
<pre><code class="language-javascript">function Component({}) {
    let [state, set_state] = useState(10);
}
</code></pre>
<p>Because Dioxus needs to work with the rules of Rust, we need to provide a way for the component to do some internal bookkeeping. That's what the <code>Context</code> object is: a place for the component to store state, manage listeners, and allocate elements. Advanced users of Dioxus will want to learn how to properly leverage the <code>Context</code> object to build robust, performant extensions for Dioxus.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Post((cx /* &lt;-- our Context object*/, props): Component&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{ })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-forward"><a class="header" href="#moving-forward">Moving forward</a></h2>
<p>Next chapter, we'll talk about composing Elements and Components across files to build a larger Dioxus App.</p>
<p>For more references on components, make sure to check out:</p>
<ul>
<li><a href="concepts/">Components in depth</a></li>
<li><a href="concepts/">Lifecycles</a></li>
<li><a href="concepts/">The Context object</a></li>
<li><a href="concepts/">Optional Prop fields</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusing-importing-and-exporting-components"><a class="header" href="#reusing-importing-and-exporting-components">Reusing, Importing, and Exporting Components</a></h1>
<p>As your application grows in size, you'll want to start breaking your UI into components and, eventually, different files. This is a great idea to encapsulate functionality of your UI and scale your team.</p>
<p>Let's say our app looks something like this:</p>
<pre><code class="language-shell">├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App, |c| c);
}

fn App((cx, props): Component&lt;()&gt;) -&gt; Element {} 

#[derive(PartialEq, Props)]
struct PostProps{}
fn Post((cx, props): Component&lt;PostProps&gt;) -&gt; Element {} 

#[derive(PartialEq, Props)]
struct VoteButtonsProps {}
fn VoteButtons((cx, props): Component&lt;VoteButtonsProps&gt;) -&gt; Element {} 

#[derive(PartialEq, Props)]
struct TitleCardProps {}
fn TitleCard((cx, props): Component&lt;TitleCardProps&gt;) -&gt; Element {} 

#[derive(PartialEq, Props)]
struct MetaCardProps {}
fn MetaCard((cx, props): Component&lt;MetaCardProps&gt;) -&gt; Element {} 

#[derive(PartialEq, Props)]
struct ActionCardProps {}
fn ActionCard((cx, props): Component&lt;ActionCardProps&gt;) -&gt; Element {} 
</code></pre></pre>
<p>That's a lot of components for one file! We've successfully refactored our app into components, but we should probably start breaking it up into a file for each component.</p>
<h2 id="breaking-into-different-files"><a class="header" href="#breaking-into-different-files">Breaking into different files</a></h2>
<p>Fortunately, Rust has a built-in module system that's much cleaner than what you might be used to in JavaScript. Because <code>VoteButtons</code>, <code>TitleCard</code>, <code>MetaCard</code>, and <code>ActionCard</code> all belong to the <code>Post</code> component, let's put them all in a folder together called &quot;post&quot;. We'll make a file for each component and move the props and render function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/action.rs

use dioxus::prelude::*;

#[derive(PartialEq, Props)]
struct ActionCardProps {}
fn ActionCard((cx, props): Component&lt;ActionCardProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<p>We should also create a <code>mod.rs</code> file in the <code>post</code> folder so we can use it from our <code>main.rs</code>. Our <code>Post</code> component and its props will go into this file.</p>
<pre><code class="language-shell">├── Cargo.toml
└── src
    ├── main.rs
    └── post
        ├── vote.rs
        ├── title.rs
        ├── meta.rs
        ├── action.rs
        └── mod.rs
</code></pre>
<p>In our <code>main.rs</code>, we'll want to declare the <code>post</code> module so we can access our <code>Post</code> component.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App, |c| c);
}

mod post;

fn App((cx, props): Component&lt;()&gt;) -&gt; Element {
    cx.render(rsx!{
        post::Post {
            id: Uuid::new_v4(),
            score: 10,
            comment_count: 10,
            post_time: std::Instant::now(),
            url: &quot;example&quot;.to_string(),
            title: &quot;Title&quot;.to_string(),
            original_poster: &quot;me&quot;.to_string()
        }
    })
} 
</code></pre></pre>
<p>If you tried to build this app right now, you'll get an error message saying that <code>Post is private, trying changing it to public</code>. This is because we haven't properly exported our component! To fix this, we need to make sure both the Props and Component are declared as &quot;public&quot;:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/mod.rs

use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct PostProps {}
pub fn Post((cx, props): Component&lt;PostProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<p>While we're here, we also need to make sure each of our subcomponents are included as modules and exported.</p>
<p>Our &quot;post/mod.rs&quot; file will eventually look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dioxus::prelude::*;

mod vote;
mod title;
mod meta;
mod action;

#[derive(Properties, PartialEq)]
pub struct PostProps {
    id: uuid::Uuid,
    score: i32,
    comment_count: u32,
    post_time: std::time::Instant,
    url: String,
    title: String,
    original_poster: String
}

pub fn Post((cx, props): Component&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;post-container&quot;
            vote::VoteButtons {
                score: props.score,
            }
            title::TitleCard {
                title: props.title,
                url: props.url,
            }
            meta::MetaCard {
                original_poster: props.original_poster,
                post_time: props.post_time,
            }
            action::ActionCard {
                post_id: props.id
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Ultimately, including and exporting components is governed by Rust's module system. <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">The Rust book is a great resource to learn about these concepts in greater detail.</a></p>
<h2 id="final-structure"><a class="header" href="#final-structure">Final structure:</a></h2>
<pre><code class="language-shell">├── Cargo.toml
└── src
    ├── main.rs
    └── post
        ├── vote.rs
        ├── title.rs
        ├── meta.rs
        ├── action.rs
        └── mod.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs:
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App, |c| c);
}

mod post;

fn App((cx, props): Component&lt;()&gt;) -&gt; Element {
    cx.render(rsx!{
        post::Post {
            id: Uuid::new_v4(),
            score: 10,
            comment_count: 10,
            post_time: std::Instant::now(),
            url: &quot;example&quot;.to_string(),
            title: &quot;Title&quot;.to_string(),
            original_poster: &quot;me&quot;.to_string()
        }
    })
} 
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/mod.rs
use dioxus::prelude::*;

mod vote;
mod title;
mod meta;
mod action;

#[derive(Properties, PartialEq)]
pub struct PostProps {
    id: uuid::Uuid,
    score: i32,
    comment_count: u32,
    post_time: std::time::Instant,
    url: String,
    title: String,
    original_poster: String
}

pub fn Post((cx, props): Component&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;post-container&quot;
            vote::VoteButtons {
                score: props.score,
            }
            title::TitleCard {
                title: props.title,
                url: props.url,
            }
            meta::MetaCard {
                original_poster: props.original_poster,
                post_time: props.post_time,
            }
            action::ActionCard {
                post_id: props.id
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/vote.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct VoteButtonsProps {}
pub fn VoteButtons((cx, props): Component&lt;VoteButtonsProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/title.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct TitleCardProps {}
pub fn TitleCard((cx, props): Component&lt;TitleCardProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/meta.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct MetaCardProps {}
pub fn MetaCard((cx, props): Component&lt;MetaCardProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/action.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct ActionCardProps {}
pub fn ActionCard((cx, props): Component&lt;ActionCardProps&gt;) -&gt; Element {} 
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-forward-1"><a class="header" href="#moving-forward-1">Moving forward</a></h2>
<p>Next chapter, we'll start to add use code to hide and show Elements with conditional rendering.</p>
<p>For more reading on components:</p>
<ul>
<li><a href="concepts/">Components in depth</a></li>
<li><a href="concepts/">Lifecycles</a></li>
<li><a href="concepts/">The Context object</a></li>
<li><a href="concepts/">Optional Prop fields</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-lists-and-keys"><a class="header" href="#conditional-lists-and-keys">Conditional Lists and Keys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-interactivity"><a class="header" href="#adding-interactivity">Adding Interactivity</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handlers"><a class="header" href="#event-handlers">Event handlers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifecycle-updates-and-effects"><a class="header" href="#lifecycle-updates-and-effects">Lifecycle, updates, and effects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-state"><a class="header" href="#managing-state">Managing State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks-and-internal-state"><a class="header" href="#hooks-and-internal-state">Hooks and Internal State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-state"><a class="header" href="#global-state">Global State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-1"><a class="header" href="#error-handling-1">Error handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects"><a class="header" href="#effects">Effects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-async"><a class="header" href="#working-with-async">Working with Async</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suspense"><a class="header" href="#suspense">Suspense</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-callbacks"><a class="header" href="#async-callbacks">Async Callbacks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h1>
<p>So far, we've covered the basics of Dioxus. We've talked about:</p>
<ul>
<li>Elements</li>
<li>Components</li>
<li>Interactivity</li>
<li>State Management</li>
<li>Async Actions</li>
<li>Styling</li>
</ul>
<p>In this chapter, we'll build a real-world weather app that combines everything we've learned into a cute application that you can run locally. It'll let us monitor different locations simultaneously and periodically check for updates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-app"><a class="header" href="#new-app">New app</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structuring-our-app"><a class="header" href="#structuring-our-app">Structuring our app</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-state"><a class="header" href="#defining-state">Defining State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-components"><a class="header" href="#defining-components">Defining Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing"><a class="header" href="#publishing">Publishing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topics-in-depth"><a class="header" href="#topics-in-depth">Topics in Depth</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rsx"><a class="header" href="#rsx">RSX</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="props"><a class="header" href="#props">Props</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memoization"><a class="header" href="#memoization">Memoization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-guides"><a class="header" href="#advanced-guides">Advanced Guides</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memoization-1"><a class="header" href="#memoization-1">Memoization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rsx-in-depth"><a class="header" href="#rsx-in-depth">RSX in Depth</a></h1>
<p>The RSX macro makes it very easy to assemble complex UIs with a very natural Rust syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(div {
    button {
        &quot;Add todo&quot;,
        onclick: move |e| todos.write().new_todo()
    }
    ul {
        class: &quot;todo-list&quot;
        (todos.iter().map(|(key, todo)| rsx!(
            li { 
                class: &quot;beautiful-todo&quot;
                key: &quot;f&quot;
                h3 { &quot;{todo.title}&quot; }
                p { &quot;{todo.contents}&quot;}
            }
        )))
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>In this section, we'll cover the <code>rsx!</code> macro in depth. If you prefer to learn through examples, the <code>reference</code> guide has plenty of examples on how to use <code>rsx!</code> effectively.</p>
<h3 id="element-structure"><a class="header" href="#element-structure">Element structure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div {
    hidden: false,
    &quot;some text&quot;
    child {}
    Component {}
    {/* literal tokens that resolve to vnodes */}
}

<span class="boring">}
</span></code></pre></pre>
<p>Each element takes a comma-separated list of expressions to build the node. Roughly, here's how they work:</p>
<ul>
<li><code>name: value</code> sets a property on this element.</li>
<li><code>&quot;text&quot;</code> adds a new text element</li>
<li><code>tag {}</code> adds a new child element</li>
<li><code>CustomTag {}</code> adds a new child component</li>
<li><code>{expr}</code> pastes the <code>expr</code> tokens literally. They must be <code>IntoIterator&lt;T&gt; where T: IntoVnode</code> to work properly</li>
</ul>
<p>Commas are entirely optional, but might be useful to delineate between elements and attributes.</p>
<p>The <code>render</code> function provides an <strong>extremely efficient</strong> allocator for VNodes and text, so try not to use the <code>format!</code> macro in your components. Rust's default <code>ToString</code> methods pass through the global allocator, but all text in components is allocated inside a manually-managed Bump arena. To push you in the right direction, all text-based attributes take <code>std::fmt::Arguments</code> directly, so you'll want to reach for <code>format_args!</code> when the built-in <code>f-string</code> interpolation just doesn't cut it.</p>
<h3 id="ignoring-cxrender-with-rsxcx-"><a class="header" href="#ignoring-cxrender-with-rsxcx-">Ignoring <code>cx.render</code> with <code>rsx!(cx, ...)</code></a></h3>
<p>Sometimes, writing <code>cx.render</code> is a hassle. The `rsx! macro will accept any token followed by a comma as the target to call &quot;render&quot; on:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!( div {} ))
// becomes
rsx!(cx, div {})
<span class="boring">}
</span></code></pre></pre>
<h3 id="conditional-rendering-1"><a class="header" href="#conditional-rendering-1">Conditional Rendering</a></h3>
<p>Sometimes, you might not want to render an element given a condition. The rsx! macro will accept any tokens directly contained with curly braces, provided they resolve to a type that implements <code>IntoIterator&lt;VNode&gt;</code>. This lets us write any Rust expression that resolves to a VNode:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!({
    if enabled {
        rsx!(cx, div {&quot;enabled&quot;})
    } else {
        rsx!(cx, li {&quot;disabled&quot;})
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>A convenient way of hiding/showing an element is returning an <code>Option&lt;VNode&gt;</code>. When combined with <code>and_then</code>, we can succinctly control the display state given some boolean:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!({
    a.and_then(rsx!(div {&quot;enabled&quot;}))
})
<span class="boring">}
</span></code></pre></pre>
<p>It's important to note that the expression <code>rsx!()</code> is typically lazy - this expression must be <em>rendered</em> to produce a VNode. When using match statements, we must render every arm as to avoid the <code>no two closures are identical</code> rule that Rust imposes:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this will not compile!
match case {
    true =&gt; rsx!(div {}),
    false =&gt; rsx!(div {})
}

// the nodes must be rendered first
match case {
    true =&gt; rsx!(cx, div {}),
    false =&gt; rsx!(cx, div {})
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<p>Again, because anything that implements <code>IntoIterator&lt;VNode&gt;</code> is valid, we can use lists directly in our <code>rsx!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

cx.render(rsx!{
    ul {
        {items.iter().map(|f| rsx!(li { &quot;a&quot; }))}
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>Sometimes, it makes sense to render VNodes into a list:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut items = vec![];

for _ in 0..5 {
    items.push(rsx!(cx, li {} ))
}

rsx!(cx, {items} )
<span class="boring">}
</span></code></pre></pre>
<h4 id="lists-and-keys"><a class="header" href="#lists-and-keys">Lists and Keys</a></h4>
<p>When rendering the VirtualDom to the screen, Dioxus needs to know which elements have been added and which have been removed. These changes are determined through a process called &quot;diffing&quot; - an old set of elements is compared to a new set of elements. If an element is removed, then it won't show up in the new elements, and Dioxus knows to remove it.</p>
<p>However, with lists, Dioxus does not exactly know how to determine which elements have been added or removed if the order changes or if an element is added or removed from the middle of the list.</p>
<p>In these cases, it is vitally important to specify a &quot;key&quot; alongside the element. Keys should be persistent between renders.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render_list(cx: Context, items: HashMap&lt;String, Todo&gt;) -&gt; Element {
    rsx!(cx, ul {
        {items.iter().map(|key, item| {
            li {
                key: key,
                h2 { &quot;{todo.title}&quot; }
                p { &quot;{todo.contents}&quot; }
            }
        })}
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>There have been many guides made for keys in React, so we recommend reading up to understand their importance:</p>
<ul>
<li><a href="https://reactjs.org/docs/lists-and-keys.html">React guide on keys</a></li>
<li><a href="https://kentcdodds.com/blog/understanding-reacts-key-prop">Importance of keys (Medium)</a></li>
</ul>
<h3 id="complete-reference"><a class="header" href="#complete-reference">Complete Reference</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text = &quot;example&quot;;

cx.render(rsx!{
    div {
        h1 { &quot;Example&quot; },

        {title}

        // fstring interpolation
        &quot;{text}&quot;

        p {
            // Attributes
            tag: &quot;type&quot;,

            // Anything that implements display can be an attribute
            abc: 123,
            
            enabled: true,

            // attributes also supports interpolation
            // `class` is not a restricted keyword unlike JS and ClassName
            class: &quot;big small wide short {text}&quot;,

            class: format_args!(&quot;attributes take fmt::Arguments. {}&quot;, 99),

            tag: {&quot;these tokens are placed directly&quot;}

            // Children
            a { &quot;abcder&quot; },

            // Children with attributes
            h2 { &quot;hello&quot;, class: &quot;abc-123&quot; },

            // Child components
            CustomComponent { a: 123, b: 456, key: &quot;1&quot; },

            // Child components with paths
            crate::components::CustomComponent { a: 123, b: 456, key: &quot;1&quot; },

            // Iterators
            { (0..3).map(|i| rsx!( h1 {&quot;{:i}&quot;} )) },

            // More rsx!, or even html!
            { rsx! { div { } } },
            { html! { &lt;div&gt; &lt;/div&gt; } },

            // Matching
            // Requires rendering the nodes first.
            // rsx! is lazy, and the underlying closures cannot have the same type
            // Rendering produces the VNode type
            {match rand::gen_range::&lt;i32&gt;(1..3) {
                1 =&gt; rsx!(cx, h1 { &quot;big&quot; })
                2 =&gt; rsx!(cx, h2 { &quot;medium&quot; })
                _ =&gt; rsx!(cx, h3 { &quot;small&quot; })
            }}

            // Optionals
            {true.and_then(|f| rsx!( h1 {&quot;Conditional Rendering&quot;} ))}

            // Child nodes
            {cx.children()}

            // Any expression that is `IntoVNode`
            {expr}
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vnodes-with-rsx-html-and-nodefactory"><a class="header" href="#vnodes-with-rsx-html-and-nodefactory">VNodes with RSX, HTML, and NodeFactory</a></h1>
<p>Many modern frameworks provide a domain-specific-language for declaring user-interfaces. In the case of React, this language extension is called JSX and must be handled through additional dependencies and pre/post processors to transform your source code. With Rust, we can simply provide a procedural macro in the Dioxus dependency itself that mimics the JSX language.</p>
<p>With Dioxus, we actually ship two different macros - a macro that mimics JSX (the <code>html!</code> macro) and a macro that mimics Rust's native nested-struct syntax (the <code>rsx!</code> macro). These macros simply transform their inputs into NodeFactory calls.</p>
<p>For instance, this html! call:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>html!(&lt;div&gt; &quot;hello world&quot; &lt;/div&gt;)
<span class="boring">}
</span></code></pre></pre>
<p>becomes this NodeFactory call:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|f| f.element(
    dioxus_elements::div, // tag
    [], // listeners
    [], // attributes
    [f.static_text(&quot;hello world&quot;)], // children
    None // key
)
<span class="boring">}
</span></code></pre></pre>
<p>The NodeFactory API is fairly ergonomic, making it a viable option to use directly. The NodeFactory API is also compile-time correct and has incredible syntax highlighting support. We use what Rust calls a &quot;unit type&quot; - the <code>dioxus_elements::div</code> and associated methods to ensure that a <code>div</code> can only have attributes associated with <code>div</code>s. This lets us tack on relevant documentation, autocomplete support, and jump-to-definition for methods and attributes.</p>
<p><img src="concepts/../images/compiletimecorrect.png" alt="Compile time correct syntax" /></p>
<h2 id="html-macro"><a class="header" href="#html-macro">html! macro</a></h2>
<p>The html! macro supports a limited subset of the html standard. Rust's macro parsing tools are somewhat limited, so all text between tags <em>must be quoted</em>.</p>
<p>However, writing HTML by hand is a bit tedious - IDE tools for Rust don't support linting/autocomplete/syntax highlighting. We suggest using RSX - it's more natural for Rust programs and <em>does</em> integrate well with Rust IDE tools.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;jane&quot;;
let pending = false;
let count = 10;

dioxus::ssr::render_lazy(html! {
    &lt;div&gt;
        &lt;p&gt; &quot;Hello, {name}!&quot; &lt;/p&gt;
        &lt;p&gt; &quot;Status: {pending}!&quot; &lt;/p&gt;
        &lt;p&gt; &quot;Count {count}!&quot; &lt;/p&gt;
    &lt;/div&gt;
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="rsx-macro"><a class="header" href="#rsx-macro">rsx! macro</a></h2>
<p>The rsx! macro is a VNode builder macro designed especially for Rust programs. Writing these should feel very natural, much like assembling a struct. VSCode also supports these with code folding, bracket-tabbing, bracket highlighting, section selecting, inline documentation, GOTO definition, and refactoring support.</p>
<p>When helpful, the Dioxus VSCode extension provides a way of converting a selection of HTML directly to RSX, so you can import templates from the web directly into your existing app.</p>
<p>It's also a bit easier on the eyes than HTML.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dioxus::ssr::render_lazy(rsx! {
    div {
        p {&quot;Hello, {name}!&quot;}
        p {&quot;Status: {pending}!&quot;}
        p {&quot;Count {count}!&quot;}
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>In the next section, we'll cover the <code>rsx!</code> macro in more depth.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-elements"><a class="header" href="#custom-elements">Custom Elements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-renderer"><a class="header" href="#custom-renderer">Custom Renderer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-components"><a class="header" href="#server-side-components">Server-side components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bundling-and-distributing"><a class="header" href="#bundling-and-distributing">Bundling and Distributing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
